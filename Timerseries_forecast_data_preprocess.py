# -*- coding: utf-8 -*-
"""Timerseries_forecast_Data_PreProcess.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IbjhcgZCWwoVxTrrgX0l0OhfZL8CZeLj
"""


import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from pandas import DataFrame

def data_preprocessing(data):
    pd.DataFrame(data)

    #grab the first row for the header
    new_header = data.iloc[0] 

    #take the data less the header row
    data = data[1:] 
    data.columns = new_header

    #create date column using year,month,day and hour attribute
    data['Date']=pd.to_datetime(data[['year','month','day','hour']])

    #drop unnecessary attributes
    data = data.drop(['year','month','day','hour','No','TEMP','PRES','DEWP','RAIN','wd','WSPM','CO','Date'], axis = 1)

    #convert station name to numeric value
    data['station'] = np.where(data['station'], 1, data['station'])

    #convert dataset from object to float type
    data = data.apply(pd.to_numeric)

    #backward fill all null values in the dataframe
    data.fillna(method='bfill', inplace=True)

    return data

def heat_map(data):
    #show correlation heatmap
    cor_data=data[['PM2.5','PM10','SO2','NO2','O3']]
    cor_cols = cor_data.columns.tolist()
    plt.matshow(cor_data.corr())
    plt.xticks(range(len(cor_cols)), cor_cols)
    plt.yticks(range(len(cor_cols)), cor_cols)
    plt.colorbar()
    plt.show()

"""**A function to Grouped raw data into 24 hours and average is taken for each pollutant concentration, 8 hours in case of co and o3.**"""

#group data function
def group_data(data):
    data["PM10_24hr_avg"] = data.groupby(['station'])["PM10"].rolling(window = 24, min_periods = 16).mean().values
    data["PM2.5_24hr_avg"] = data.groupby(['station'])["PM2.5"].rolling(window = 24, min_periods = 16).mean().values
    data["SO2_24hr_avg"] = data.groupby(['station'])["SO2"].rolling(window = 24, min_periods = 16).mean().values
    data["NO2_24hr_avg"] = data.groupby(['station'])["NO2"].rolling(window = 24, min_periods = 16).mean().values
    data["O3_8hr_max"] = data.groupby(['station'])["O3"].rolling(window = 8, min_periods = 1).max().values
    #backward fill all null values in the dataframe
    data.fillna(method='bfill', inplace=True)
    return data

"""**Functions for Calculating the sub indices of each individual pollutant**"""

## PM2.5 Sub-Index calculation
def get_PM25_subindex(x):
    if x <= 30:
        return x * 50 / 30
    elif x <= 60:
        return 50 + (x - 30) * 50 / 30
    elif x <= 90:
        return 100 + (x - 60) * 100 / 30
    elif x <= 120:
        return 200 + (x - 90) * 100 / 30
    elif x <= 250:
        return 300 + (x - 120) * 100 / 130
    elif x > 250:
        return 400 + (x - 250) * 100 / 130
    else:
        return 0


## PM10 Sub-Index calculation
def get_PM10_subindex(x):
    if x <= 50:
        #return x * 50/ 50
        return x
    elif x <= 100:
        #return  50 + (x -  50) *  50 / 50
        return x
    elif x <= 250:
        return 100 + (x - 100) * 100 / 150
    elif x <= 350:
        return 200 + (x - 250)
    elif x <= 430:
        return 300 + (x - 350) * 100 / 80
    elif x > 430:
        return 400 + (x - 430) * 100 / 80
    else:
        return 0


## SO2 Sub-Index calculation
def get_SO2_subindex(x):
    if x <= 40:
        return x * 50 / 40
    elif x <= 80:
        return 50 + (x - 40) * 50 / 40
    elif x <= 380:
        return 100 + (x - 80) * 100 / 300
    elif x <= 800:
        return 200 + (x - 380) * 100 / 420
    elif x <= 1600:
        return 300 + (x - 800) * 100 / 800
    elif x > 1600:
        return 400 + (x - 1600) * 100 / 800
    else:
        return 0



## NO2 Sub-Index calculation
def get_NO2_subindex(x):
    if x <= 40:
        return x * 50 / 40
    elif x <= 80:
        return 50 + (x - 40) * 50 / 40
    elif x <= 180:
        return 100 + (x - 80) * 100 / 100
    elif x <= 280:
        return 200 + (x - 180) * 100 / 100
    elif x <= 400:
        return 300 + (x - 280) * 100 / 120
    elif x > 400:
        return 400 + (x - 400) * 100 / 120
    else:
        return 0



## O3 Sub-Index calculation
def get_O3_subindex(x):
    if x <= 50:
        return x * 50 / 50
    elif x <= 100:
        return 50 + (x - 50) * 50 / 50
    elif x <= 168:
        return 100 + (x - 100) * 100 / 68
    elif x <= 208:
        return 200 + (x - 168) * 100 / 40
    elif x <= 748:
        return 300 + (x - 208) * 100 / 539
    elif x > 748:
        return 400 + (x - 400) * 100 / 539
    else:
        return 0

"""**After all the sub indices are calculated it's time to find the overall AQI index The final AQI is the maximum Sub-Index among the available sub-indices with at least one of PM2.5 and PM10 should be availability and at least 3/7 other pollutants availablity**"""

def calculate_sub_index(data):
    data["PM2.5_SubIndex"] = data["PM2.5_24hr_avg"].apply(lambda x: get_PM25_subindex(x))
    data["PM10_SubIndex"] = data["PM10_24hr_avg"].apply(lambda x: get_PM10_subindex(x))
    data["SO2_SubIndex"] = data["SO2_24hr_avg"].apply(lambda x: get_SO2_subindex(x))
    data["NO2_SubIndex"] = data["NO2_24hr_avg"].apply(lambda x: get_NO2_subindex(x))
    data["O3_SubIndex"] = data["O3_8hr_max"].apply(lambda x: get_O3_subindex(x))
    return data


def calculate_AQI(data):

    data["Checks"] = (data["PM2.5_SubIndex"] > 0).astype(int) + \
                    (data["PM10_SubIndex"] > 0).astype(int) + \
                    (data["SO2_SubIndex"] > 0).astype(int) + \
                    (data["NO2_SubIndex"] > 0).astype(int) + \
                    (data["O3_SubIndex"] > 0).astype(int)

    data["AQI"] = round(data[["PM2.5_SubIndex", "PM10_SubIndex", "SO2_SubIndex", "NO2_SubIndex",
                                         "O3_SubIndex"]].max(axis = 1))
    data.loc[data["PM2.5_SubIndex"] + data["PM10_SubIndex"] <= 0, "AQI"] = np.NaN
    data.loc[data.Checks < 3, "AQI"] = np.NaN

    #data["AQL"] = data["AQI"].apply(lambda x: get_AQI_bucket(x))
    #data.fillna(method='bfill',inplace=True)
    return data

def main():
    #load datset as pandas dataframe
    data = pd.read_csv('/Users/itcarelaptops/Documents/Project Files/PData/PRSA_Data_Changping_20130301-20170228.csv', delimiter = ',' , header=None)

    #pass data to preprocessing function
    data = data_preprocessing(data)

    #plot a heat_map b/w useful attributes
    heat_map(data)

    #Pass raw pollutants and measure 16/8 hours average value
    data = group_data(data)

    #calculate sub_index of each pollutants using 16/8 average value
    data = calculate_sub_index(data)

    #calculate AQI from Raw pollutants sub_index value
    data = calculate_AQI(data)

    #Get series of values from data for Time Forecast
    series = data["AQI"]
    
    return series, data

if __name__ == "__main__":
    
    series,data = main()
  